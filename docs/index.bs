<pre class='metadata'>
Title: Service Workers Nightly
Status: ED
ED: https://w3c.github.io/ServiceWorker/
TR: https://www.w3.org/TR/service-workers/
Shortname: service-workers
Level:
Editor: Alex Russell, Google, slightlyoff@chromium.org
Editor: Jungkee Song, Samsung Electronics, jungkee.song@samsung.com
Editor: Jake Archibald, Google, jakearchibald@chromium.org
Editor: Marijn Kruisselbrink, Google, mek@chromium.org
Repository: w3c/ServiceWorker
Group: webplatform
Status Text: This is a living document addressing new features including foreign fetch and header-based installation, etc. Readers need to be aware that this specification includes unstable features. Implementers interested in implementing this specification should refer to the latest TR of <a href="https://w3c.github.io/ServiceWorker/v1/">Service Workers 1</a> instead.
Abstract: This specification describes a method that enables applications to take advantage of persistent background processing, including hooks to enable bootstrapping of web applications while offline.
Abstract:
Abstract: The core of this system is an event-driven <a>Web Worker</a>, which responds to events dispatched from documents and other sources. A system for managing installation, versions, and upgrades is provided.
Abstract:
Abstract: The service worker is a generic entry point for event-driven background processing in the Web Platform that is <!--<a href="#extensibility">extensible by other specifications</a>-->.
Markup Shorthands: css no, markdown yes
</pre>

<pre class=biblio>
{
  "unsanctioned-tracking": {
    "href": "https://www.w3.org/2001/tag/doc/unsanctioned-tracking/",
    "title": "Unsanctioned Web Tracking",
    "date": "17 July 2015",
    "status": "Finding of the W3C TAG",
    "publisher": "W3C TAG"
  }
}
</pre>

<section>
  <h2 id="motivations">Motivations</h2>

  *This section is non-normative.*
  
  Web Applications traditionally assume that the network is reachable. This assumption pervades the platform. HTML documents are loaded over HTTP and traditionally fetch all of their sub-resources via subsequent HTTP requests. This places web content at a disadvantage versus other technology stacks.

  The <a>service worker</a> is designed first to redress this balance by providing a Web Worker context, which can be started by a runtime when navigations are about to occur. This event-driven worker is registered against an origin and a path (or pattern), meaning it can be consulted when navigations occur to that location. Events that correspond to network requests are dispatched to the worker and the responses generated by the worker may override default network stack behavior. This puts the <a>service worker</a>, conceptually, between the network and a document renderer, allowing the <a>service worker</a> to provide content for documents, even while offline.

  Web developers familiar with previous attempts to solve the offline problem have reported a deficit of flexibility in those solutions. As a result, the <a>service worker</a> is highly procedural, providing a maximum of flexibility at the price of additional complexity for developers. Part of this complexity arises from the need to keep <a>service workers</a> responsive in the face of a single-threaded execution model. As a result, APIs exposed by <a>service workers</a> are almost entirely asynchronous, a pattern familiar in other JavaScript contexts but accentuated here by the need to avoid blocking document and resource loading.

  Developers using the <a lt="application cache">HTML5 Application Cache</a> have also <a href="http://alistapart.com/article/application-cache-is-a-douchebag">reported that several attributes</a> of the design contribute to <a href="http://alistapart.com/article/application-cache-is-a-douchebag#section6">unrecoverable errors</a>. A key design principle of the <a>service worker</a> is that errors should *always* be recoverable. Many details of the update process of <a>service workers</a> are designed to avoid these hazards.

  <a>Service workers</a> are started and kept alive by their relationship to events, not documents. This design borrows heavily from developer and vendor experience with <a>Shared Workers</a> and <a href="https://developer.chrome.com/extensions/background_pages">Chrome Background Pages</a>. A key lesson from these systems is the necessity to time-limit the execution of background processing contexts, both to conserve resources and to ensure that background context loss and restart is top-of-mind for developers. As a result, <a>service workers</a> bear more than a passing resemblance to <a href="https://developer.chrome.com/extensions/event_pages">Chrome Event Pages</a>, the successor to Background Pages. <a>Service workers</a> may be started by user agents *without an attached document* and may be killed by the user agent at nearly any time. Conceptually, <a>service workers</a> can be thought of as Shared Workers that can start, process events, and die without ever handling messages from documents. Developers are advised to keep in mind that <a>service workers</a> may be started and killed many times a second.

  <a>Service workers</a> are generic, event-driven, time-limited script contexts that run at an origin. These properties make them natural endpoints for a range of runtime services that may outlive the context of a particular document, e.g. handling push notifications, background data synchronization, responding to resource requests from other origins, or receiving centralized updates to expensive-to-calculate data (e.g., geolocation or gyroscope).
</section>

<section>
  <h2 id="model">Model</h2>

  <section dfn-for="service worker">
    <h3 id="service-worker-concept">Service Worker</h3>

    A <dfn export id="dfn-service-worker" for="">service worker</dfn> is a type of <a>web worker</a>. A <a>service worker</a> executes in the registering <a>service worker client</a>'s <a for="/">origin</a>.
    
    A <a>service worker</a> has an associated <dfn export id="dfn-state">state</dfn>, which is one of *parsed*, *installing*, *installed*, *activating*, *activated*, and *redundant*. It is initially *parsed*.

    A <a>service worker</a> has an associated <dfn export id="dfn-script-url">script url</dfn> (a <a for="/">URL</a>).
    
    A <a>service worker</a> has an associated <dfn export id="dfn-type">type</dfn> which is either "<code>classic</code>" or "<code>module</code>". Unless stated otherwise, it is "<code>classic</code>".
    
    A <a>service worker</a> has an associated <dfn export id="dfn-containing-service-worker-registration">containing service worker registration</dfn> (a <a>service worker registration</a>), which contains itself.
    
    A <a>service worker</a> has an associated <dfn export id="dfn-service-worker-id">id</dfn> (an opaque string), which uniquely identifies itself during the lifetime of its <a>containing service worker registration</a>.
    
    A <a>service worker</a> is dispatched a set of <dfn export id="dfn-lifecycle-events">lifecycle events</dfn>, <a>install</a> and <a>activate</a>, and <dfn export id="dfn-functional-events">functional events</dfn> including <a>fetch</a>.
    
    A <a>service worker</a> has an associated <dfn export id="dfn-script-resource">script resource</dfn> (a <a>script</a>), which represents its own script resource. It is initially set to null.
    
    A <a>script resource</a> has an associated <dfn export for="script resource" id="dfn-has-ever-been-evaluated-flag">has ever been evaluated flag</dfn>. It is initially unset.
    
    A <a>script resource</a> has an associated <dfn export for="script resource" id="dfn-https-state">HTTPS state</dfn> (an <a>HTTPS state value</a>). It is initially "<code>none</code>".
    
    A <a>script resource</a> has an associated <dfn export for="script resource" id="dfn-referrer-policy">referrer policy</dfn> (a <a href="https://w3c.github.io/webappsec-referrer-policy/#referrer-policy">referrer policy</a>). It is initially the empty string.
    
    A <a>service worker</a> has an associated <dfn export id="dfn-script-resource-map">script resource map</dfn> which is an <a>ordered map</a> where the keys are <a for="/">URLs</a> and the values are <a>responses</a>.
    
    A <a>service worker</a> has an associated <dfn export id="dfn-skip-waiting-flag">skip waiting flag</dfn>. Unless stated otherwise it is unset.
    
    A <a>service worker</a> has an associated <dfn export id="dfn-imported-scripts-updated-flag">imported scripts updated flag</dfn>. It is initially unset.
    
    A <a>service worker</a> has an associated <dfn export id="dfn-set-of-event-types-to-handle">set of event types to handle</dfn> whose element type is an <a>event listener</a>'s event type. It is initially set to null.
    
    A <a>service worker</a> has an associated <dfn export id="dfn-foreign-fetch-scopes">list of foreign fetch scopes</dfn> whose element type is a <a for="/">URL</a>. It is initially empty.
    
    A <a>service worker</a> has an associated <dfn export id="dfn-foreign-fetch-origins">list of foreign fetch origins</dfn> whose element type is a <a for="/">URL</a>. It is initially empty.

    <section>
      <h4 id="service-worker-lifetime">Lifetime</h4>

      The lifetime of a <a>service worker</a> is tied to the execution lifetime of events and not references held by <a>service worker clients</a> to the {{ServiceWorker}} object.
      
      A user agent *may* <a>terminate</a> <a>service workers</a> at any time it:

        * Has no event to handle.
        * Detects abnormal operation: such as infinite loops and tasks exceeding imposed time limits (if any) while handling the events.
    </section>
  </section>

  <section dfn-for="service worker registration">
    <h3 id="service-worker-registration-concept">Service Worker Registration</h3>

    A <dfn export id="dfn-service-worker-registration" for="">service worker registration</dfn> is a tuple of a <a>scope url</a> and a set of <a>service workers</a>, an <a>installing worker</a>, a <a>waiting worker</a>, and an <a>active worker</a>. A user agent *may* enable many <a>service worker registrations</a> at a single origin so long as the <a>scope url</a> of the <a>service worker registration</a> differs. A <a>service worker registration</a> of an identical <a>scope url</a> when one already exists in the user agent causes the existing <a>service worker registration</a> to be replaced.
    
    A <a>service worker registration</a> has an associated <dfn export id="dfn-scope-url">scope url</dfn> (a <a for="/">URL</a>).
    
    A <a>service worker registration</a> has an associated <dfn export id="dfn-registration-script-url">registering script url</dfn> (a <a for="/">URL</a>).
    
    A <a>service worker registration</a> has an associated <dfn export id="dfn-installing-worker">installing worker</dfn> (a <a>service worker</a> or null) whose <a for="service worker">state</a> is *installing*. It is initially set to null.
    
    A <a>service worker registration</a> has an associated <dfn export id="dfn-waiting-worker">waiting worker</dfn> (a <a>service worker</a> or null) whose <a for="service worker">state</a> is *installed*. It is initially set to null.
    
    A <a>service worker registration</a> has an associated <dfn export export id="dfn-active-worker">active worker</dfn> (a <a>service worker</a> or null) whose <a for="service worker">state</a> is either *activating* or *activated*. It is initially set to null.
    
    A <a>service worker registration</a> has an associated <dfn export id="dfn-last-update-check-time">last update check time</dfn>. It is initially set to null.
    
    A <a>service worker registration</a> has an associated <dfn export id="dfn-uninstalling-flag">uninstalling flag</dfn>. It is initially unset.
    
    A <a>service worker registration</a> has one or more <dfn export id="dfn-service-worker-registration-task-queue">task queues</dfn> that back up the <a>tasks</a> from its <a>active worker</a>'s <a>event loop</a>'s corresponding <a for="/">task queues</a>. (The target task sources for this back up operation are the <a>handle fetch task source</a> and the <a>handle functional event task source</a>.) The user agent dumps the <a>active worker</a>'s <a>tasks</a> to the <a>service worker registration</a>'s <a for="service worker registration">task queues</a> when the <a>active worker</a> is <a>terminated</a> and <a lt="queue a task">re-queues those tasks</a> to the <a>active worker</a>'s <a>event loop</a>'s corresponding <a for="/">task queues</a> when the <a>active worker</a> spins off. Unlike the <a for="/">task queues</a> owned by <a>event loops</a>, the <a>service worker registration</a>'s <a for="service worker registration">task queues</a> are not processed by any <a>event loops</a> in and of itself.

    <section>
      <h4 id="service-worker-registration-lifetime">Lifetime</h4>
      
      A user agent *must* persistently keep a list of <a>registered</a> <a>service worker registrations</a> unless otherwise they are explicitly <a>unregistered</a>. A user agent has a <a>scope to registration map</a> that stores the entries of the tuple of <a>service worker registration</a>'s <a>scope url</a> and the corresponding <a>service worker registration</a>. The lifetime of <a>service worker registrations</a> is beyond that of the {{ServiceWorkerRegistration}} objects which represent them within the lifetime of their corresponding <a>service worker clients</a>.
    </section>
  </section>

  <section dfn-for="service worker client">
    <h3 id="service-worker-client-concept">Service Worker Client</h3>

    A <dfn export id="dfn-service-worker-client" for="">service worker client</dfn> is a type of <a>environment</a> or <a>environment settings object</a>.

    A <a>service worker client</a> has an algorithm defined as the <dfn export for="service worker client">origin</dfn> that returns the <a>service worker client</a>'s <a>creation URL</a>'s <a for="url">origin</a> if the <a>service worker client</a> is a type of <a>environment</a>, and the <a>service worker client</a>'s <a for="environment settings object">origin</a> otherwise.

    A <dfn export id="dfn-window-client">window client</dfn> is a <a>service worker client</a> whose <a for="environment settings object">global object</a> is a {{Window}} object.

    A <dfn export id="dfn-dedicatedworker-client">dedicated worker client</dfn> is a <a>service worker client</a> whose <a for="environment settings object">global object</a> is a {{DedicatedWorkerGlobalScope}} object.

    A <dfn export id="dfn-sharedworker-client">shared worker client</dfn> is a <a>service worker client</a> whose <a for="environment settings object">global object</a> is a {{SharedWorkerGlobalScope}} object.

    A <dfn export id="dfn-worker-client">worker client</dfn> is either a <a>dedicated worker client</a> or a <a>shared worker client</a>.
  </section>

  <section>
    <h3 id="selection">Selection and Use</h3>

    A <a>service worker client</a> independently <a>selects</a> and <a>uses</a> a <a>service worker registration</a> for its own loading and its subresources. The <dfn export id="dfn-service-worker-registration-selection">selection</dfn> of a <a>service worker registration</a>, upon a <a>non-subresource request</a>, is a process of either <a>matching</a> a <a>service worker registration</a> from <a>scope to registration map</a> or inheriting an existing <a>service worker registration</a> from its parent or owner context depending on the request's <a for="request">url</a>.

    When the request's <a for="request">url</a> is not <a lt="is local">local</a>, a <a>service worker client</a> <a>matches</a> a <a>service worker registration</a> from <a>scope to registration map</a>. That is, the <a>service worker client</a> attempts to consult a <a>service worker registration</a> whose <a>scope url</a> <a>matches</a> its <a>creation URL</a>.

    When the request's <a for="request">url</a> <a>is local</a>, if the <a>service worker client</a>'s <a>responsible browsing context</a> is a <a>nested browsing context</a> or the <a>service worker client</a> is a <a>worker client</a>, the <a>service worker client</a> inherits the <a>service worker registration</a> from its <a>parent browsing context</a>'s environment or one of <a>the worker's Documents</a>' environment, respectively, if it exists.

    If the <a>selection</a> was successful, the <a>selected</a> <a>service worker registration</a>'s <a>active worker</a> starts to <dfn export id="dfn-control">control</dfn> the <a>service worker client</a>. Otherwise, the flow returns to <a>fetch</a> where it falls back to the default behavior. When a <a>service worker client</a> is <a>controlled</a> by an <a>active worker</a>, it is considered that the <a>service worker client</a> is <dfn id="dfn-use">using</dfn> the <a>active worker</a>'s <a>containing service worker registration</a>.
  </section>

  <section>
    <h3 id="task-sources">Task Sources</h3>

    The following additional <a>task sources</a> are used by <a>service workers</a>.
      
      : The <dfn export id="dfn-handle-fetch-task-source">handle fetch task source</dfn>
      :: This <a>task source</a> is used for <a>dispatching</a> <a>fetch</a> events to <a>service workers</a>.
      : The <dfn export id="dfn-handle-functional-event-task-source">handle functional event task source</dfn>
      :: This <a>task source</a> is used for features that <a>dispatch</a> other <a>functional</a> events, e.g. <a href="https://w3c.github.io/push-api/#h-the-push-event">push</a> events, to <a>service workers</a>.
        
        Note: A user agent may use a separate task source for each functional event type in order to avoid a head-of-line blocking phenomenon for certain functional events. For instance, a user agent may use a different task source for <a href="http://web-alarms.sysapps.org/#firing-task-event-to-service-worker">task</a> events from other task sources.
  </section>

  <section>
    <h3 id="user-agent-shutdown">User Agent Shutdown</h3>

    A user agent *must* maintain the state of its stored <a>service worker registrations</a> across restarts with the following rules:

      * An <a>installing worker</a> does not persist but discarded. If the <a>installing worker</a> was the only <a>service worker</a> for the <a>service worker registration</a>, the <a>service worker registration</a> is discarded.
      * A <a>waiting worker</a> promotes to an <a>active worker</a>.

    To attain this, the user agent *must* invoke <a>Handle User Agent Shutdown</a> when it terminates.
  </section>
</section>
<section>
  <h2 id="document-context">Client Context</h2>

  <div class="example">
    Bootstrapping with a service worker:

    <pre highlight="js">
      // scope defaults to the path the script sits in
      // "/" in this example
      navigator.serviceWorker.register("/serviceworker.js").then(registration => {
        console.log("success!");
        if (registration.installing) {
          registration.installing.postMessage("Howdy from your installing page.");
        }
      }, err => {
        console.error("Installing the worker failed!", err);
      });
    </pre>
  </div>

  <section>
    <h3 id="serviceworker-interface">{{ServiceWorker}}</h3>

    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface ServiceWorker : EventTarget {
        readonly attribute USVString scriptURL;
        readonly attribute ServiceWorkerState state;
        void postMessage(any message, optional sequence&lt;object&gt; transfer = []);

        // event
        attribute EventHandler onstatechange;
      };
      ServiceWorker implements AbstractWorker;

      enum ServiceWorkerState {
        "installing",
        "installed",
        "activating",
        "activated",
        "redundant"
      };
    </pre>

    A {{ServiceWorker}} object represents a <a>service worker</a>. Each {{ServiceWorker}} object is associated with a <a>service worker</a>. Multiple separate objects implementing the {{ServiceWorker}} interface across documents and workers can all be associated with the same <a>service worker</a> simultaneously.

    A {{ServiceWorker}} object has an associated {{ServiceWorkerState}} object which is itself associated with <a>service worker</a>'s <a>state</a>.

    <section>
      <h4 id="service-worker-url">{{ServiceWorker/scriptURL}}</h4>

      The <dfn attribute for="ServiceWorker"><code>scriptURL</code></dfn> attribute *must* return the <a>service worker</a>'s <a lt="URL serializer">serialized</a> <a>script url</a>.

      <div class="example">
        For example, consider a document created by a navigation to <code>https://example.com/app.html</code> which <a>matches</a> via the following registration call which has been previously executed:

        <pre highlight="js">
          // Script on the page https://example.com/app.html
          navigator.serviceWorker.register("/service_worker.js");
        </pre>

        The value of <code>navigator.serviceWorker.controller.scriptURL</code> will be "<code>https://example.com/service_worker.js</code>".
      </div>
    </section>

    <section>
      <h4 id="service-worker-state">{{ServiceWorker/state}}</h4>

      The <dfn attribute for="ServiceWorker"><code>state</code></dfn> attribute *must* return the value (in {{ServiceWorkerState}} enumeration) to which it was last set.
    </section>

    <section algorithm="service-worker-postmessage">
      <h4 id="service-worker-postmessage">{{ServiceWorker/postMessage(message, transfer)}}</h4>

      The <dfn method for="ServiceWorker"><code>postMessage(|message|, |transfer|)</code></dfn> method *must* run these steps:
      
        1. If the {{ServiceWorker/state}} attribute value of the <a>context object</a> is "<code>redundant</code>", <a>throw</a> an "{{InvalidStateError}}" exception and abort these steps. 
        1. Let |serviceWorker| be the <a>service worker</a> represented by the <a>context object</a>.
        1. Invoke <a>Run Service Worker</a> algorithm with |serviceWorker| as the argument.
        1. Let |destination| be the {{ServiceWorkerGlobalScope}} object associated with |serviceWorker|.
        1. Let |targetRealm| be |destination|'s <a for="global object">Realm</a>.
        1. Let |incumbentSettings| be the <a>incumbent settings object</a>, and |incumbentGlobal| its <a for="environment settings object">global object</a>.
        1. Let |cloneRecord| be <a abstract-op>StructuredCloneWithTransfer</a>(|message|, |transfer|, |targetRealm|). If this <a>throws</a> an exception, <a lt="throw">rethrow</a> that exception and abort these steps.
        1. Let |clonedMessage| be |cloneRecord|.\[[Clone]].
        1. Let |newPorts| be a new <a lt="frozen array type">frozen array</a> consisting of all {{MessagePort}} objects in |cloneRecord|.\[[TransferList]], if any, maintaining their relative order.
        1. <a>Queue a task</a> that runs the following steps:
          1. Create an event |e| that uses the {{ExtendableMessageEvent}} interface, with the event type {{message!!event}}, which does not bubble and is not cancelable.
          1. Let the {{ExtendableMessageEvent/data}} attribute of |e| be initialized to |clonedMessage|.
          1. Let the {{ExtendableMessageEvent/origin}} attribute of |e| be initialized to the <a lt="Unicode serialization of an origin">Unicode serialization</a> of |incumbentSettings|'s <a for="resource">origin</a>.
          1. If |incumbentGlobal| is a {{ServiceWorkerGlobalScope}} object, let the {{ExtendableMessageEvent/source}} attribute of |e| be initialized to a new {{ServiceWorker}} object that represents |incumbentGlobal|'s <a for="ServiceWorkerGlobalScope">service worker</a>.
          1. Else if |incumbentGlobal| is a {{Window}} object, let the {{ExtendableMessageEvent/source}} attribute of |e| be initialized to a new {{WindowClient}} object that represents |incumbentGlobal|'s <a for="/">browsing context</a>.
          1. Else, let it be initialized to a new {{Client}} object that represents the worker associated with |incumbentGlobal|.
          1. Let the {{ExtendableMessageEvent/ports}} attribute of |e| be initialized to |newPorts|.
          1. <a>Dispatch</a> |e| at |destination|.
          
            The <a>task</a> *must* use the <a>DOM manipulation task source</a>.
    </section>

    <section>
      <h4 id="service-worker-event-handler">Event handler</h4>

      The following is the <a>event handler</a> (and its corresponding <a>event handler event type</a>) that *must* be supported, as <a>event handler IDL attributes</a>, by all objects implementing {{ServiceWorker}} interface:

      <table class="data">
        <thead>
          <tr>
            <th><a>event handler</a></th>
            <th><a>event handler event type</a></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><dfn attribute for="ServiceWorker"><code>onstatechange</code></dfn></td>
            <td>{{ServiceWorker/statechange}}</td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>

  <section>
    <h3 id="serviceworkerregistration-interface">{{ServiceWorkerRegistration}}</h3>

    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface ServiceWorkerRegistration : EventTarget {
        readonly attribute ServiceWorker? installing;
        readonly attribute ServiceWorker? waiting;
        readonly attribute ServiceWorker? active;

        readonly attribute USVString scope;

        [NewObject] Promise&lt;void&gt; update();
        [NewObject] Promise&lt;boolean&gt; unregister();

        // event
        attribute EventHandler onupdatefound;
      };
    </pre>

    A {{ServiceWorkerRegistration}} object represents a <a>service worker registration</a>. Each {{ServiceWorkerRegistration}} object is associated with a <dfn for="ServiceWorkerRegistration">service worker registration</dfn> (a <a>service worker registration</a>). Multiple separate objects implementing the {{ServiceWorkerRegistration}} interface across documents and workers can all be associated with the same <a>service worker registration</a> simultaneously.

    <section algorithm="navigator-service-worker-installing">
      <h4 id="navigator-service-worker-installing">{{ServiceWorkerRegistration/installing}}</h4>

      <dfn attribute for="ServiceWorkerRegistration"><code>installing</code></dfn> attribute *must* return the value to which it was last set.

      Note: The {{ServiceWorker}} objects returned from this attribute getter that represent the same <a>service worker</a> are the same objects.
    </section>

    <section algorithm="navigator-service-worker-waiting">
      <h4 id="navigator-service-worker-waiting">{{ServiceWorkerRegistration/waiting}}</h4>

      <dfn attribute for="ServiceWorkerRegistration"><code>waiting</code></dfn> attribute *must* return the value to which it was last set.

      Note: The {{ServiceWorker}} objects returned from this attribute getter that represent the same <a>service worker</a> are the same objects.
    </section>

    <section algorithm="navigator-service-worker-active">
      <h4 id="navigator-service-worker-active">{{ServiceWorkerRegistration/active}}</h4>

      <dfn attribute for="ServiceWorkerRegistration"><code>active</code></dfn> attribute *must* return the value to which it was last set.

      Note: The {{ServiceWorker}} objects returned from this attribute getter that represent the same <a>service worker</a> are the same objects.
    </section>

    <section algorithm="service-worker-registration-scope">
      <h4 id="service-worker-registration-scope">{{ServiceWorkerRegistration/scope}}</h4>

      The <dfn attribute for="ServiceWorkerRegistration"><code>scope</code></dfn> attribute *must* return <a for="ServiceWorkerRegistration">service worker registration</a>'s <a lt="URL serializer">serialized</a> <a>scope url</a>.

      <div class="example">
        In the example in section 3.1.1, the value of <code>registration.scope</code>, obtained from <code>navigator.serviceWorker.ready.then(registration => console.log(registration.scope))</code> for example, will be "<code>https://example.com/</code>".
      </div>
    </section>

    <section algorithm="service-worker-registration-update">
      <h4 id="service-worker-registration-update">{{ServiceWorkerRegistration/update()}}</h4>

      <dfn method for="ServiceWorkerRegistration"><code>update()</code></dfn> method *must* run these steps:

        1. Let |p| be a <a>promise</a>.
        1. Let |registration| be the <a for="ServiceWorkerRegistration">service worker registration</a>.
        1. Let |newestWorker| be the result of running <a>Get Newest Worker</a> algorithm passing |registration| as its argument.
        1. If |newestWorker| is null, reject |p| with an "{{InvalidStateError}}" exception and abort these steps.
        1. If the <a>context object</a>'s <a>relevant settings object</a>'s <a for="environment settings object">global object</a> |globalObject| is a {{ServiceWorkerGlobalScope}} object, and |globalObject|'s associated <a for="ServiceWorkerGlobalScope">service worker</a>'s <a>state</a> is *installing*, reject |p| with an "{{InvalidStateError}}" exception and abort these steps.
        1. Let |job| be the result of running <a>Create Job</a> with *update*, |registration|'s <a>scope url</a>, |newestWorker|'s <a>script url</a>, |p|, and the <a>context object</a>'s <a>relevant settings object</a> |client|.
        1. Set |job|'s <a>worker type</a> to |newestWorker|'s <a for="service worker">type</a>.
        1. Invoke <a>Schedule Job</a> with |job|.
        1. Return |p|.
    </section>

    <section algorithm="navigator-service-worker-unregister">
      <h4 id="navigator-service-worker-unregister">{{ServiceWorkerRegistration/unregister()}}</h4>

      Note: The {{ServiceWorkerRegistration/unregister()}} method unregisters the <a>service worker registration</a>. It is important to note that the currently <a>controlled</a> <a>service worker client</a>'s <a>active service worker</a>'s <a>containing service worker registration</a> is effective until all the <a>service worker clients</a> (including itself) using this <a>service worker registration</a> unload. That is, the {{ServiceWorkerRegistration/unregister()}} method only affects subsequent <a lt="navigate">navigations</a>.

      <dfn method for="ServiceWorkerRegistration"><code>unregister()</code></dfn> method *must* run these steps:

        1. Let |p| be a <a>promise</a>.
        1. Let |job| be the result of running <a>Create Job</a> with *unregister*, the <a>scope url</a> of the <a for="ServiceWorkerRegistration">service worker registration</a>, null, |p|, and the <a>context object</a>'s <a>relevant settings object</a> |client|.
        1. Invoke <a>Schedule Job</a> with |job|.
        1. Return |p|.
    </section>

    <section>
      <h4 id="service-worker-registration-event-handler">Event handler</h4>

      The following is the <a>event handler</a> (and its corresponding <a>event handler event type</a>) that *must* be supported, as <a>event handler IDL attributes</a>, by all objects implementing {{ServiceWorkerRegistration}} interface:

      <table class="data">
        <thead>
          <tr>
            <th><a>event handler</a></th>
            <th><a>event handler event type</a></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><dfn attribute for="ServiceWorkerRegistration"><code>onupdatefound</code></dfn></td>
            <td><code><a>updatefound</a></code></td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>

  <section>
    <h3 id="navigator-serviceworker">{{Navigator/serviceWorker|navigator.serviceWorker}}</h3>

    <pre class="idl">
      partial interface Navigator {
        [SecureContext, SameObject] readonly attribute ServiceWorkerContainer serviceWorker;
      };

      partial interface WorkerNavigator {
        [SecureContext, SameObject] readonly attribute ServiceWorkerContainer serviceWorker;
      };
    </pre>

    The <dfn attribute for="Navigator,WorkerNavigator" id="navigator-service-worker-attribute"><code>serviceWorker</code></dfn> attribute *must* return the {{ServiceWorkerContainer}} object that is associated with the <a>context object</a>.
  </section>

  <section>
    <h3 id="serviceworkercontainer-interface">{{ServiceWorkerContainer}}</h3>

    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface ServiceWorkerContainer : EventTarget {
        readonly attribute ServiceWorker? controller;
        [SameObject] readonly attribute Promise&lt;ServiceWorkerRegistration&gt; ready;

        [NewObject] Promise&lt;ServiceWorkerRegistration&gt; register(USVString scriptURL, optional RegistrationOptions options);

        [NewObject] Promise&lt;any&gt; getRegistration(optional USVString clientURL = "");
        [NewObject] Promise&lt;sequence&lt;ServiceWorkerRegistration&gt;&gt; getRegistrations();

        void startMessages();


        // events
        attribute EventHandler oncontrollerchange;
        attribute EventHandler onmessage; // event.source of message events is ServiceWorker object
      };
    </pre>
    <pre class="idl" id="registration-option-list-dictionary">
      dictionary RegistrationOptions {
        USVString scope;
        WorkerType type = "classic";
      };
    </pre>

    The user agent *must* create a {{ServiceWorkerContainer}} object when a {{Navigator}} object or a {{WorkerNavigator}} object is created and associate it with that object.

    A {{ServiceWorkerContainer}} provides capabilities to register, unregister, and update the <a>service worker registrations</a>, and provides access to the state of the <a>service worker registrations</a> and their associated <a>service workers</a>.

    A {{ServiceWorkerContainer}} has an associated <dfn for="ServiceWorkerContainer">service worker client</dfn>, which is a <a for="/">service worker client</a> whose <a for="environment settings object">global object</a> is associated with the {{Navigator}} object or the {{WorkerNavigator}} object that the {{ServiceWorkerContainer}} is retrieved from.

    A {{ServiceWorkerContainer}} object has an associated <dfn for="ServiceWorkerContainer">ready promise</dfn> (a <a>promise</a>). It is initially set to a new <a>promise</a>.

    A {{ServiceWorkerContainer}} object has a <a>task source</a> called the <dfn export id="dfn-client-message-queue" for="ServiceWorkerContainer">client message queue</dfn>, initially empty. A <a for="ServiceWorkerContainer">client message queue</a> can be enabled or disabled, and is initially disabled. When a {{ServiceWorkerContainer}} object's <a for="ServiceWorkerContainer">client message queue</a> is enabled, the <a>event loop</a> *must* use it as one of its <a>task sources</a>. When the {{ServiceWorkerContainer}} object's <a>relevant global object</a> is a {{Window}} object, all <a>tasks</a> <a lt="queue a task">queued</a> on its <a for="ServiceWorkerContainer">client message queue</a> *must* be associated with its <a>relevant settings object</a>'s <a>responsible document</a>.

    <section algorithm="navigator-service-worker-controller">
      <h4 id="navigator-service-worker-controller">{{ServiceWorkerContainer/controller}}</h4>

      <dfn attribute for="ServiceWorkerContainer"><code>controller</code></dfn> attribute *must* run these steps:

        1. Let |client| be the <a>context object</a>'s <a for="ServiceWorkerContainer">service worker client</a>.
        1. Return the {{ServiceWorker}} object that represents |client|'s <a>active service worker</a>.

      Note: {{ServiceWorkerContainer/controller|navigator.serviceWorker.controller}} returns <code>null</code> if the request is a force refresh (shift+refresh). The {{ServiceWorker}} objects returned from this attribute getter that represent the same <a>service worker</a> are the same objects.
    </section>

    <section algorithm="navigator-service-worker-ready">
      <h4 id="navigator-service-worker-ready">{{ServiceWorkerContainer/ready}}</h4>

      <dfn attribute for="ServiceWorkerContainer"><code>ready</code></dfn> attribute *must* run these steps:

      
        1. If the <a>context object</a>'s <a for="ServiceWorkerContainer">ready promise</a> is settled, return the <a>context object</a>'s <a for="ServiceWorkerContainer">ready promise</a>.
        1. Let |client| be the <a>context object</a>'s <a for="ServiceWorkerContainer">service worker client</a>.
        1. Let |registration| be null.
        1. Let |clientURL| be |client|'s <a>creation URL</a>.
        1. Run the following substeps <a>in parallel</a>:
          1. *CheckRegistration*: If the result of running <a>Match Service Worker Registration</a> algorithm with |clientURL| as its argument is not null, then:
            1. Set |registration| to the result value.
          1. Else:  
            1. Wait until <a>scope to registration map</a> has a new entry.
            1. Jump to the step labeled *CheckRegistration*.  
          1. If |registration|'s <a>active worker</a> is null, wait until |registration|'s <a>active worker</a> changes.
              
            Note: Implementers should consider this condition is met when the corresponding registration request gets to the step 6 of <a>Activate</a> algorithm.
            
          1. Resolve <a>context object</a>'s <a for="ServiceWorkerContainer">ready promise</a> with the {{ServiceWorkerRegistration}} object which represents |registration|.
        1. Return <a>context object</a>'s <a for="ServiceWorkerContainer">ready promise</a>.
      

      Note: When the {{ServiceWorkerContainer/ready}} attribute is accessed, the returned <a>promise</a> will never reject. Instead, it waits until the <a>promise</a> resolves with a <a>service worker registration</a> that has an <a>active worker</a>.
    </section>

    <section algorithm="navigator-service-worker-register">
      <h4 id="navigator-service-worker-register">{{ServiceWorkerContainer/register(scriptURL, options)}}</h4>

      Note: The {{ServiceWorkerContainer/register(scriptURL, options)}} method creates or updates a <a>service worker registration</a> for the given <a>scope url</a>. If successful, a <a>service worker registration</a> ties the provided |scriptURL| to a <a>scope url</a>, which is subsequently used for <a>navigation matching</a>.

      <dfn method for="ServiceWorkerContainer"><code>register(|scriptURL|, |options|)</code></dfn> method *must* run these steps:

        1. Let |p| be a <a>promise</a>.
        1. Let |client| be the <a>context object</a>'s <a for="ServiceWorkerContainer">service worker client</a>.
        1. Let |scriptURL| be the result of <a lt="URL parser">parsing</a> |scriptURL| with the <a>context object</a>'s <a>relevant settings object</a>'s <a>API base URL</a>.
        1. Let |scopeURL| be null.
        1. If |options|.{{RegistrationOptions/scope}} is <a>present</a>, set |scopeURL| to the result of <a lt="URL parser">parsing</a> |options|.{{RegistrationOptions/scope}} with the <a>context object</a>'s <a>relevant settings object</a>'s <a>API base URL</a>.
        1. Invoke [[#start-register-algorithm]] with |scopeURL|, |scriptURL|, |p|, |client|, |client|'s <a>creation URL</a> and |options|.{{RegistrationOptions/type}}.
        1. Return |p|.
    </section>

    <section algorithm="navigator-service-worker-getRegistration">
      <h4 id="navigator-service-worker-getRegistration">{{ServiceWorkerContainer/getRegistration(clientURL)}}</h4>

      <dfn method for="ServiceWorkerContainer"><code>getRegistration(|clientURL|)</code></dfn> method *must* run these steps:

        1. Let |client| be the <a>context object</a>'s <a for="ServiceWorkerContainer">service worker client</a>.
        1. Let |clientURL| be the result of <a lt="URL parser">parsing</a> |clientURL| with the <a>context object</a>'s <a>relevant settings object</a>'s <a>API base URL</a>.
        1. If |clientURL| is failure, return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. If the <a for="resource">origin</a> of |clientURL| is not |client|'s <a for="resource">origin</a>, return a |promise| rejected with a "{{SecurityError}}" exception.
        1. Let |promise| be a new <a>promise</a>.
        1. Run the following substeps <a>in parallel</a>:
          1. Let |registration| be the result of running <a>Match Service Worker Registration</a> algorithm with |clientURL| as its argument.
          1. If |registration| is not null, then:
            1. Resolve |promise| with the {{ServiceWorkerRegistration}} object which represents |registration|.
          1. Else:
            1. Resolve |promise| with undefined.
        1. Return |promise|.
    </section>

    <section algorithm="navigator-service-worker-getRegistrations">
      <h4 id="navigator-service-worker-getRegistrations">{{ServiceWorkerContainer/getRegistrations()}}</h4>

      <dfn method for="ServiceWorkerContainer"><code>getRegistrations()</code></dfn> method *must* run these steps:

        1. Let |client| be the <a>context object</a>'s <a for="ServiceWorkerContainer">service worker client</a>.
        1. Let |promise| be a new <a>promise</a>.
        1. Run the following substeps <a>in parallel</a>:
          1. Let |array| be an empty array.
          1. For each <a>Record</a> {\[[key]], \[[value]]} |entry| of <a>scope to registration map</a>:
            1. If the <a for="resource">origin</a> of the result of <a lt="URL parser">parsing</a> |entry|.\[[key]] is the <a lt="same origin">same</a> as |client|'s <a for="resource">origin</a>, and |entry|.\[[value]]'s <a>uninstalling flag</a> is unset, add the {{ServiceWorkerRegistration}} object associated with |entry|.\[[value]] to the |array|.
          1. Resolve |promise| with |array|.
        1. Return |promise|.
    </section>

    <section algorithm="navigator-service-worker-startMessages">
      <h4 id="navigator-service-worker-startMessages">{{ServiceWorkerContainer/startMessages()}}</h4>

      <dfn method for="ServiceWorkerContainer"><code>startMessages()</code></dfn> method *must* enable the <a>context object</a>'s <a for="ServiceWorkerContainer">client message queue</a> if it is not enabled.
    </section>

    <section>
      <h4 id="service-worker-container-event-handlers">Event handlers</h4>

      The following are the <a>event handlers</a> (and their corresponding <a>event handler event types</a>) that *must* be supported, as <a>event handler IDL attributes</a>, by all objects implementing the {{ServiceWorkerContainer}} interface:

      <table class="data">
        <thead>
          <tr>
            <th><a>event handler</a></th>
            <th><a>event handler event type</a></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><dfn attribute for="ServiceWorkerContainer"><code>oncontrollerchange</code></dfn></td>
            <td><code><a>controllerchange</a></code></td>
          </tr>
          <tr>
            <td><dfn attribute for="ServiceWorkerContainer"><code>onmessage</code></dfn></td>
            <td><code><a>message</a></code></td>
          </tr>
        </tbody>
      </table>

      The first time the <a>context object</a>'s {{ServiceWorkerContainer/onmessage}} IDL attribute is set, its <a for="ServiceWorkerContainer">client message queue</a> *must* be enabled.
    </section>
  </section>
  <section>
    <h3 id="document-context-events">Events</h3>

    The following event is dispatched on {{ServiceWorker}} object:

    <table class="data">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when&mldr;</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn event for="ServiceWorker"><code>statechange</code></dfn></td>
          <td>{{Event}}</td>
          <td>The {{ServiceWorker/state}} attribute of the {{ServiceWorker}} object is changed.</td>
        </tr>
      </tbody>
    </table>

    The following event is dispatched on {{ServiceWorkerRegistration}} object:

    <table class="data">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when&mldr;</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn event for="ServiceWorkerRegistration" id="service-worker-registration-updatefound-event"><code>updatefound</code></dfn></td>
          <td>{{Event}}</td>
          <td>The <a for="ServiceWorkerRegistration">service worker registration</a>'s <a>installing worker</a> changes. (See step 8 of the <a>Install</a> algorithm.)</td>
        </tr>
      </tbody>
    </table>

    The following events are dispatched on {{ServiceWorkerContainer}} object:

    <table class="data" dfn-for="ServiceWorkerContainer">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when&mldr;</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn event id="service-worker-container-controllerchange-event"><code>controllerchange</code></dfn></td>
          <td>{{Event}}</td>
          <td>The <a for="ServiceWorkerContainer">service worker client</a>'s <a>active service worker</a> changes. (See step 9.2 of the <a>Activate</a> algorithm. The <a>skip waiting flag</a> of a <a>service worker</a> causes <a>activation</a> of the <a>service worker registration</a> to occur while <a>service worker clients</a> are <a>using</a> the <a>service worker registration</a>, {{ServiceWorkerContainer/controller|navigator.serviceWorker.controller}} immediately reflects the <a>active worker</a> as the <a>service worker</a> that <a>controls</a> the <a>service worker client</a>.)</td>
        </tr>
      </tbody>
    </table>
  </section>
</section>

<section>
  <h2 id="execution-context">Execution Context</h2>

  <div class="example">
    Serving Cached Resources:

    <pre highlight="js">
      // caching.js
      self.addEventListener("install", event => {
        event.waitUntil(
          // Open a cache of resources.
          caches.open("shell-v1").then(cache => {
            // Begins the process of fetching them.
            // The coast is only clear when all the resources are ready.
            return cache.addAll([
              "/app.html",
              "/assets/v1/base.css",
              "/assets/v1/app.js",
              "/assets/v1/logo.png",
              "/assets/v1/intro_video.webm"
            ]);
          })
        );
      });

      self.addEventListener("fetch", event => {
        // No "fetch" events are dispatched to the service worker until it
        // successfully installs and activates.

        // All operations on caches are async, including matching URLs, so we use
        // promises heavily. e.respondWith() even takes promises to enable this:
        event.respondWith(
          caches.match(e.request).then(response => {
            return response || fetch(e.request);
          }).catch(() => {
            return caches.match("/fallback.html");
          })
        );
      });
    </pre>
  </div>

  <section>
    <h3 id="serviceworkerglobalscope-interface">{{ServiceWorkerGlobalScope}}</h3>

    <pre class="idl">
      [Global=(Worker,ServiceWorker), Exposed=ServiceWorker]
      interface ServiceWorkerGlobalScope : WorkerGlobalScope {
        // A container for a list of Client objects that correspond to
        // browsing contexts (or shared workers) that are on the origin of this SW
        [SameObject] readonly attribute Clients clients;
        [SameObject] readonly attribute ServiceWorkerRegistration registration;

        [NewObject] Promise&lt;void&gt; skipWaiting();

        attribute EventHandler oninstall;
        attribute EventHandler onactivate;
        attribute EventHandler onfetch;
        attribute EventHandler onforeignfetch;

        // event
        attribute EventHandler onmessage; // event.source of the message events is Client object
      };
    </pre>

    A {{ServiceWorkerGlobalScope}} object represents the global execution context of a <a for="/">service worker</a>. A {{ServiceWorkerGlobalScope}} object has an associated <dfn for="ServiceWorkerGlobalScope">service worker</dfn> (a <a>service worker</a>).

    Note: {{ServiceWorkerGlobalScope}} object provides generic, event-driven, time-limited script execution contexts that run at an origin. Once successfully <a>registered</a>, a <a>service worker</a> is started, kept alive and killed by their relationship to events, not <a>service worker clients</a>. Any type of synchronous requests must not be initiated inside of a <a>service worker</a>.

    <section>
      <h4 id="service-worker-global-scope-clients">{{ServiceWorkerGlobalScope/clients}}</h4>

      <dfn attribute for="ServiceWorkerGlobalScope"><code>clients</code></dfn> attribute *must* return the {{Clients}} object that is associated with the <a>context object</a>.
    </section>

    <section>
      <h4 id="service-worker-global-scope-registration">{{ServiceWorkerGlobalScope/registration}}</h4>

      The <dfn attribute for="ServiceWorkerGlobalScope"><code>registration</code></dfn> attribute *must* return the {{ServiceWorkerRegistration}} object that represents the <a for="ServiceWorkerGlobalScope">service worker</a>'s <a>containing service worker registration</a>.
    </section>

    <section algorithm="service-worker-global-scope-skipwaiting">
      <h4 id="service-worker-global-scope-skipwaiting">{{ServiceWorkerGlobalScope/skipWaiting()}}</h4>

      Note: The {{ServiceWorkerGlobalScope/skipWaiting()}} method allows this <a>service worker</a> to progress from the <a>registration</a>'s <a>waiting</a> position to <a>active</a> even while <a>service worker clients</a> are <a>using</a> the <a>registration</a>.

      <dfn method for="ServiceWorkerGlobalScope"><code>skipWaiting()</code></dfn> method *must* run these steps:

        1. Let |promise| be a new <a>promise</a>.
        1. Run the following substeps <a>in parallel</a>:
          1. Set <a>service worker</a>'s <a>skip waiting flag</a>
          1. If <a>service worker</a>'s <a>state</a> is <em>installed</em>, then:
            1. Run <a>Activate</a> algorithm passing <a>service worker</a>'s <a>registration</a> as the argument.  
          1. Resolve |promise| with undefined.
        1. Return |promise|.
    </section>

    <section>
      <h4 id="service-worker-global-scope-event-handlers">Event handlers</h4>

      The following are the <a>event handlers</a> (and their corresponding <a>event handler event types</a>) that *must* be supported, as <a>event handler IDL attributes</a>, by all objects implementing the {{ServiceWorkerGlobalScope}} interface:

      <table class="data">
        <thead>
          <tr>
            <th><a>event handler</a></th>
            <th><a>event handler event type</a></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><dfn attribute for="ServiceWorkerGlobalScope"><code>oninstall</code></dfn></td>
            <td><code><a>install</a></code></td>
          </tr>
          <tr>
            <td><dfn attribute for="ServiceWorkerGlobalScope"><code>onactivate</code></dfn></td>
            <td><code><a>activate</a></code></td>
          </tr>
          <tr>
            <td><dfn attribute for="ServiceWorkerGlobalScope"><code>onfetch</code></dfn></td>
            <td><code><a>fetch</a></code></td>
          </tr>
          <tr>
            <td><dfn attribute for="ServiceWorkerGlobalScope"><code>onforeignfetch</code></dfn></td>
            <td><code><a>foreignfetch</a></code></td>
          </tr>
          <tr>
            <td><dfn attribute for="ServiceWorkerGlobalScope"><code>onmessage</code></dfn></td>
            <td>{{message!!event}}</td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>

  <section>
    <h3 id="client-interface">{{Client}}</h3>

    <pre class="idl">
      [Exposed=ServiceWorker]
      interface Client {
        readonly attribute USVString url;
        readonly attribute DOMString id;
        readonly attribute boolean reserved;
        void postMessage(any message, optional sequence&lt;object&gt; transfer = []);
      };

      [Exposed=ServiceWorker]
      interface WindowClient : Client {
        readonly attribute VisibilityState visibilityState;
        readonly attribute boolean focused;
        [SameObject] readonly attribute FrozenArray&lt;USVString&gt; ancestorOrigins;
        [NewObject] Promise&lt;WindowClient&gt; focus();
        [NewObject] Promise&lt;WindowClient&gt; navigate(USVString url);
      };
    </pre>

    A {{Client}} object has an associated <dfn for="Client">service worker client</dfn> (a <a>service worker client</a>).

    A {{Client}} object has an associated <dfn for="Client">reserved state</dfn>, which is either true or false.

    A {{WindowClient}} object has an associated <dfn id="dfn-service-worker-client-visibilitystate">visibility state</dfn>, which is one of {{Document/visibilityState}} attribute value.

    A {{WindowClient}} object has an associated <dfn id="dfn-service-worker-client-focusstate">focus state</dfn>, which is either true or false (initially false).

    A {{WindowClient}} object has an associated <dfn for="WindowClient">ancestor origins array</dfn>.

    <section>
      <h4 id="client-url">{{Client/url}}</h4>

      The <dfn attribute for="Client"><code>url</code></dfn> attribute *must* return the <a>context object</a>'s associated <a for="Client">service worker client</a>'s <a lt="URL serializer">serialized</a> <a>creation URL</a>.
    </section>

    <section>
      <h4 id="client-id">{{Client/id}}</h4>

      The <dfn attribute for="Client"><code>id</code></dfn> attribute *must* return its associated <a for="Client">service worker client</a>'s <a for="environment">id</a>.
    </section>

    <section>
      <h4 id="client-reserved">{{Client/reserved}}</h4>

      The <dfn attribute for="Client"><code>reserved</code></dfn> attribute *must* return the <a>context object</a>'s associated <a for="Client">reserved state</a>.
    </section>

    <section algorithm="client-postmessage">
      <h4 id="client-postmessage">{{Client/postMessage(message, transfer)}}</h4>

      The <dfn method for="Client"><code>postMessage(|message|, |transfer|)</code></dfn> method *must* run these steps:

        1. Let |sourceSettings| be the <a>context object</a>'s <a>relevant settings object</a>.
        1. Let |destination| be the {{ServiceWorkerContainer}} object whose <a for="ServiceWorkerContainer">service worker client</a> is the <a>context object</a>'s <a for="Client">service worker client</a>.
        1. If |destination| is null, <a>throw</a> an "{{InvalidStateError}}" exception.
        1. Let |targetRealm| be |destination|'s <a>relevant Realm</a>.
        1. Let |cloneRecord| be <a abstract-op>StructuredCloneWithTransfer</a>(|message|, |transfer|, |targetRealm|). If this <a>throws</a> an exception, <a lt="throw">rethrow</a> that exception and abort these steps.
        1. Let |clonedMessage| be |cloneRecord|.\[[Clone]].
        1. Let |newPorts| be a new <a lt="frozen array type">frozen array</a> consisting of all {{MessagePort}} objects in |cloneRecord|.\[[TransferList]], if any, maintaining their relative order.
        1. Add a <a>task</a> that runs the following steps to |destination|'s <a for="ServiceWorkerContainer">client message queue</a>:
          1. Create an event |e| that uses the {{MessageEvent}} interface, with the event type <a>message</a>, which does not bubble and is not cancelable.
          1. Let the <a>data</a> attribute of |e| be initialized to |clonedMessage|.
          1. Let the <a>origin</a> attribute of |e| be initialized to the <a lt="Unicode serialization of an origin">Unicode serialization</a> of |sourceSettings|'s <a for="resource">origin</a>.
          1. Let the <a>source</a> attribute of |e| be initialized to a {{ServiceWorker}} object, which represents the <a for="ServiceWorkerGlobalScope">service worker</a> associated with |sourceSettings|'s <a for="environment settings object">global object</a>.
          1. Let the <a>ports</a> attribute of |e| be initialized to |newPorts|.
          1. <a>Dispatch</a> |e| at |destination|.
    </section>

    <section>
      <h4 id="client-visibilitystate">{{WindowClient/visibilityState}}</h4>

      The <dfn attribute for="WindowClient"><code>visibilityState</code></dfn> attribute *must* return the <a>context object</a>'s <a>visibility state</a>.
    </section>

    <section>
      <h4 id="client-focused">{{WindowClient/focused}}</h4>

      The <dfn attribute for="WindowClient"><code>focused</code></dfn> attribute *must* return the <a>context object</a>'s <a>focus state</a>.
    </section>

    <section>
      <h4 id="client-ancestororigins">{{WindowClient/ancestorOrigins}}</h4>

      The <dfn attribute for="WindowClient"><code>ancestorOrigins</code></dfn> attribute *must* return the <a>context object</a>'s associated <a for="Client">service worker client</a>'s <a for="WindowClient">ancestor origins array</a>.
    </section>

    <section algorithm="client-focus">
      <h4 id="client-focus">{{WindowClient/focus()}}</h4>

      The <dfn method for="WindowClient"><code>focus()</code></dfn> method *must* run these steps:

        1. If this algorithm is not <a>triggered by user activation</a>, return a <a>promise</a> rejected with an "{{InvalidAccessError}}" exception.
        1. Let |promise| be a new <a>promise</a>.
        1. Run these substeps <a>in parallel</a>:
          1. Let |browsingContext| be the <a>context object</a>'s associated <a for="Client">service worker client</a>'s <a for="environment settings object">global object</a>'s <a for="/">browsing context</a>.
          1. Let |visibilityState| be null.
          1. Let |focusState| be false.
          1. Let |ancestorOrigins| be the empty array.
          1. <a>Queue a task</a> |task| to run the following substeps on the <a>context object</a>'s associated <a for="Client">service worker client</a>'s <a>responsible event loop</a> using the <a>user interaction task source</a>:
            1. Run the <a>focusing steps</a> with |browsingContext|.
            1. Set |visibilityState| to |browsingContext|'s <a>active document</a>'s {{Document/visibilityState}} attribute value.
            1. Set |focusState| to the result of running the <a>has focus steps</a> with |browsingContext|'s <a>active document</a> as the argument.
            1. Set |ancestorOrigins| to |browsingContext|'s <a>active document</a>'s <a>relevant global object</a>'s {{Location}} object's <a for="Location">ancestor origins array</a>.
          1. Wait for |task| to have executed.
          1. Let |windowClient| be the result of running <a>Create Window Client</a> algorithm with the <a>context object</a>'s associated <a for="Client">service worker client</a>, |visibilityState|, |focusState|, and |ancestorOrigins| as the arguments.
          1. If |windowClient|'s <a>focus state</a> is true, resolve |promise| with |windowClient|.
          1. Else, reject |promise| with a <code>TypeError</code>.
        1. Return |promise|.
    </section>

    <section algorithm="client-navigate">
      <h4 id="client-navigate">{{WindowClient/navigate(url)}}</h4>

      The <dfn method for="WindowClient"><code>navigate()</code></dfn> method *must* run these steps:

        1. Let |url| be the result of <a lt="URL parser">parsing</a> |url| with the <a>context object</a>'s <a>relevant settings object</a>'s <a>API base URL</a>.
        1. If |url| is failure, return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. If |url| is <code><a>about:blank</a></code>, return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. If the <a>context object</a>'s associated <a for="Client">service worker client</a>'s <a>active service worker</a> is not the <a>context object</a>'s <a>relevant global object</a>'s <a for="ServiceWorkerGlobalScope">service worker</a>, return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. Let |promise| be a new <a>promise</a>.
        1. Run these substeps <a>in parallel</a>:
          1. Let |browsingContext| be the <a>context object</a>'s associated <a for="Client">service worker client</a>'s <a for="environment settings object">global object</a>'s <a for="/">browsing context</a>.
          1. If |browsingContext| has <a lt="discard a document">discarded</a> its {{Document}}, reject |promise| with a <code>TypeError</code> and abort these steps.
          1. Let |navigateFailed| to false.
          1. Let |visibilityState| be null.
          1. Let |focusState| be false.
          1. Let |ancestorOrigins| be the empty array.
          1. <a>Queue a task</a> |task| to run the following substeps on the <a>context object</a>'s associated <a for="Client">service worker client</a>'s <a>responsible event loop</a> using the <a>user interaction task source</a>:
            1. <em>HandleNavigate</em>: <a>Navigate</a> |browsingContext| to |url| with <a lt="exceptions enabled flag">exceptions enabled</a>. The <a>source browsing context</a> must be |browsingContext|.
            1. If the algorithm steps invoked in the step labeled <em>HandleNavigate</em> <a>throws</a> an exception, set |navigateFailed| to true.
            1. Set |visibilityState| to |browsingContext|'s <a>active document</a>'s {{Document/visibilityState}} attribute value.
            1. Set |focusState| to the result of running the <a>has focus steps</a> with |browsingContext|'s <a>active document</a> as the argument.
            1. Set |ancestorOrigins| to |browsingContext|'s <a>active document</a>'s <a>relevant global object</a>'s {{Location}} object's <a for="Location">ancestor origins array</a>.
          1. Wait for |task| to have executed (including its asynchronous steps).
          1. If |navigateFailed| is true, reject |promise| with a <code>TypeError</code> and abort these steps.
          1. If |browsingContext|'s {{Window}} object's <a>environment settings object</a>'s <a>creation URL</a>'s <a for="resource">origin</a> is not the <a lt="same origin">same</a> as the <a for="ServiceWorkerGlobalScope">service worker</a>'s <a for="resource">origin</a>, then:
              1. Resolve |promise| with null.
              1. Abort these steps.
          1. Let |windowClient| be the result of running <a>Create Window Client</a> algorithm with |browsingContext|'s {{Window}} object's <a>environment settings object</a>, |visibilityState|, |focusState|, and |ancestorOrigins| as the arguments.
          1. Resolve |promise| with |windowClient|.
        1. Return |promise|.
    </section>
  </section>

  <section>
    <h3 id="clients-interface">{{Clients}}</h3>

    <pre class="idl">
      [Exposed=ServiceWorker]
      interface Clients {
        // The objects returned will be new instances every time
        [NewObject] Promise&lt;any&gt; get(DOMString id);
        [NewObject] Promise&lt;sequence&lt;Client&gt;&gt; matchAll(optional ClientQueryOptions options);
        [NewObject] Promise&lt;WindowClient?&gt; openWindow(USVString url);
        [NewObject] Promise&lt;void&gt; claim();
      };
    </pre>
    <pre class="idl" id="serviceworker-client-query-options-dictionary">
      dictionary ClientQueryOptions {
        boolean includeUncontrolled = false;
        boolean includeReserved = false;
        ClientType type = "window";
      };
    </pre>
    <pre class="idl" id="client-type-enum">
      enum ClientType {
        "window",
        "worker",
        "sharedworker",
        "all"
      };
    </pre>

    The user agent *must* create a {{Clients}} object when a {{ServiceWorkerGlobalScope}} object is created and associate it with that object.

    <section algorithm="clients-get">
      <h4 id="clients-get">{{Clients/get(id)}}</h4>

      The <dfn method for="Clients"><code>get(|id|)</code></dfn> method *must* run these steps:

        1. Let |promise| be a new <a>promise</a>.
        1. Run these substeps <a>in parallel</a>:
          1. For each <a>service worker client</a> |client| whose <a for="service worker client">origin</a> is the <a lt="same origin">same</a> as the associated <a for="ServiceWorkerGlobalScope">service worker</a>'s <a for="resource">origin</a>:
            1. If |client|'s <a for="environment">id</a> is not |id|, continue to the next iteration of the loop.
            1. If |client| is a type of <a>environment</a>, then:
              1. If |client|’s <a>creation URL</a> is not a <a>potentially trustworthy URL</a>, reject |promise| with a "{{SecurityError}}" exception and abort these steps.
            1. Else:
              1. If |client| is not a <a>secure context</a>, reject |promise| with a "{{SecurityError}}" exception and abort these steps.
            1. If |client| is a type of <a>environment</a> or is a <a>window client</a>, then:
              1. Let |browsingContext| be null.
              1. Let |visibilityState| be null.
              1. Let |focusState| be false.
              1. Let |ancestorOrigins| be the empty array.
              1. If |client| is a type of <a>environment</a>, set |browsingContext| to |client|’s <a for="environment">target browsing context</a>.
              1. Else, set |browsingContext| to |client|'s <a for="environment settings object">global object</a>'s <a for="/">browsing context</a>.
              1. <a>Queue a task</a> |task| to run the following substeps on |browsingContext|'s <a>event loop</a> using the <a>user interaction task source</a>:
                  1. Set |visibilityState| to |browsingContext|'s <a>active document</a>'s {{Document/visibilityState}} attribute value.
                  1. Set |focusState| to the result of running the <a>has focus steps</a> with |browsingContext|'s <a>active document</a> as the argument.
                  1. If |client| is a <a>window client</a>, set |ancestorOrigins| to |browsingContext|'s <a>active document</a>'s <a>relevant global object</a>'s {{Location}} object's <a for="Location">ancestor origins array</a>.
              1. Wait for |task| to have executed.
              1. Let |windowClient| be the result of running <a>Create Window Client</a> algorithm with |client|, |visibilityState|, |focusState|, and |ancestorOrigins| as the arguments.
              1. Resolve |promise| with |windowClient| and abort these steps.
            1. Else:
              1. Let |clientObject| be the result of running <a>Create Client</a> algorithm with |client| as the argument.
              1. Resolve |promise| with |clientObject| and abort these steps.
          1. Resolve |promise| with undefined.
        1. Return |promise|.
    </section>

    <section algorithm="clients-getall">
      <h4 id="clients-getall">{{Clients/matchAll(options)}}</h4>

      The <dfn method for="Clients"><code>matchAll(|options|)</code></dfn> method *must* run these steps:

        1. Let |promise| be a new <a>promise</a>.
        1. Run these substeps <a>in parallel</a>:
          1. Let |targetClients| be an empty array.
          1. For each <a>service worker client</a> |client| whose <a for="service worker client">origin</a> is the <a lt="same origin">same</a> as the associated <a for="ServiceWorkerGlobalScope">service worker</a>'s <a for="resource">origin</a>:
            1. If |client| is a type of <a>environment</a>, then:
              1. If |client|’s <a>creation URL</a> is not a <a>potentially trustworthy URL</a>, continue to the next iteration of the loop.
            1. Else:
              1. If |client| is not a <a>secure context</a>, continue to the next iteration of the loop.
            1. If |options|.{{ClientQueryOptions/includeUncontrolled}} is false, then:
              1. If |client|'s <a>active service worker</a> is not the associated <a for="ServiceWorkerGlobalScope">service worker</a>, continue to the next iteration of the loop.
            1. If |options|.{{ClientQueryOptions/includeReserved}} is false, then:
              1. If |client|'s <a for="environment">execution ready flag</a> is unset, continue to the next iteration of the loop.
            1. Add |client| to |targetClients|.
          1. Let |matchedClients| be an empty array.
          1. For each <a>service worker client</a> |client| in |targetClients|:
            1. If |options|.{{ClientQueryOptions/type}} is "<code>window</code>" or "<code>all</code>", and |client| is a type of <a>environment</a> or is a <a>window client</a>, then:
              1. Let |browsingContext| be null.
              1. Let |isClientEnumerable| be true.
              1. Let |visibilityState| be the empty string.
              1. Let |focusState| be false.
              1. Let |ancestorOrigins| be the empty array.
              1. If |client| is a type of <a>environment</a>, set |browsingContext| to |client|’s <a for="environment">target browsing context</a>.
              1. Else, set |browsingContext| to |client|'s <a for="environment settings object">global object</a>'s <a for="/">browsing context</a>.
              1. <a>Queue a task</a> |task| to run the following substeps on |browsingContext|'s <a>event loop</a> using the <a>user interaction task source</a>:
                1. If |browsingContext| has been <a lt="a browsing context is discarded">discarded</a>, set |isClientEnumerable| to false and abort these steps.
                1. If |client| is a window client and |client|'s <a>responsible document</a> is not |browsingContext|'s <a>active document</a>,  set |isClientEnumerable| to false and abort these steps.
                1. Set |visibilityState| to |browsingContext|'s <a>active document</a>'s {{Document/visibilityState}} attribute value.
                1. Set |focusState| to the result of running the <a>has focus steps</a> with |browsingContext|'s <a>active document</a> as the argument.
                1. It |client| is a <a>window client</a>, set |ancestorOrigins| to |browsingContext|'s <a>active document</a>'s <a>relevant global object</a>'s {{Location}} object's <a for="Location">ancestor origins array</a>.
              1. Wait for |task| to have executed.
                Note: Wait is a blocking wait, but implementers may run the iterations in parallel as long as the state is not broken.
              1. If |isClientEnumerable| is true, then:
                1. Let |windowClient| be the result of running <a>Create Window Client</a> algorithm with |client|, |visibilityState|, |focusState|, and |ancestorOrigins| as the arguments.
                1. Add |windowClient| to |matchedClients|.
            1. Else if |options|.{{ClientQueryOptions/type}} is "<code>worker</code>" or "<code>all</code>" and |client| is a <a>dedicated worker client</a>, or |options|.{{ClientQueryOptions/type}} is "<code>sharedworker</code>" or "<code>all</code>" and |client| is a <a>shared worker client</a>, then:
                1. Let |clientObject| be the result of running <a>Create Client</a> algorithm with |client| as the argument.
                1. Add |clientObject| to |matchedClients|.
          1. Sort |matchedClients| such that:
              * {{WindowClient}} objects are always placed before {{Client}} objects whose associated <a for="Client">service worker clients</a> are <a>worker clients</a>.
              * {{WindowClient}} objects that have been <a lt="focusing steps">focused</a> are placed first sorted in the most recently <a lt="focusing steps">focused</a> order, and {{WindowClient}} objects that have never been <a lt="focusing steps">focused</a> are placed next sorted in their <a for="Client">service worker clients</a>' creation order.
              * {{Client}} objects whose associated <a for="Client">service worker clients</a> are <a>worker clients</a> are placed next sorted in their <a for="Client">service worker clients</a>' creation order.
          1. Resolve |promise| with |matchedClients|.
        1. Return |promise|.
    </section>

    <section algorithm="clients-openwindow">
      <h4 id="clients-openwindow">{{Clients/openWindow(url)}}</h4>

      The <dfn method for="Clients"><code>openWindow(|url|)</code></dfn> method *must* run these steps:
        1. Let |url| be the result of <a lt="URL parser">parsing</a> |url| with the <a>context object</a>'s <a>relevant settings object</a>'s <a>API base URL</a>.
        1. If |url| is failure, return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. If |url| is <code><a>about:blank</a></code>, return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. If this algorithm is not <a>triggered by user activation</a>, return a <a>promise</a> rejected with an "{{InvalidAccessError}}" exception.
        1. Let |promise| be a new <a>promise</a>.
        1. Run these substeps <a>in parallel</a>:
          1. Let |newContext| be a new <a>top-level browsing context</a>.
          1. Let |openWindowFailed| to false.
          1. Let |visibilityState| be null.
          1. Let |focusState| be false.
          1. Let |ancestorOrigins| be the empty array.
          1. <a>Queue a task</a> |task| to run the following substeps on |newContext|'s {{Window}} object's <a>environment settings object</a>'s <a>responsible event loop</a> using the <a>user interaction task source</a>:
            1. <em>HandleNavigate</em>: <a>Navigate</a> |newContext| to |url| with <a lt="exceptions enabled flag">exceptions enabled</a> and <a>replacement enabled</a>.
            1. If the algorithm steps invoked in the step labeled <em>HandleNavigate</em> <a>throws</a> an exception, set |openWindowFailed| to true.
            1. Set |visibilityState| to |newContext|'s <a>active document</a>'s {{Document/visibilityState}} attribute value.
            1. Set |focusState| to the result of running the <a>has focus steps</a> with |newContext|'s <a>active document</a> as the argument.
            1. Set |ancestorOrigins| to |newContext|'s <a>active document</a>'s <a>relevant global object</a>'s {{Location}} object's <a for="Location">ancestor origins array</a>.
          1. Wait for |task| to have executed (including its asynchronous steps).
          1. If |openWindowFailed| is true, reject |promise| with a <code>TypeError</code> and abort these steps.
          1. If |newContext|'s {{Window}} object's <a>environment settings object</a>'s <a>creation URL</a>'s <a for="resource">origin</a> is not the <a lt="same origin">same</a> as the <a for="ServiceWorkerGlobalScope">service worker</a>'s <a for="resource">origin</a>, then:
            1. Resolve |promise| with null.
            1. Abort these steps.
          1. Let |client| be the result of running <a>Create Window Client</a> algorithm with |newContext|'s {{Window}} object's <a>environment settings object</a>, |visibilityState|, |focusState|, and |ancestorOrigins| as the arguments.
          1. Resolve |promise| with |client|.
        1. Return |promise|.
    </section>

    <section algorithm="clients-claim">
      <h4 id="clients-claim">{{Clients/claim()}}</h4>

      The <dfn method for="Clients"><code>claim()</code></dfn> method *must* run these steps:

        1. If the <a for="ServiceWorkerGlobalScope">service worker</a> is not an <a>active worker</a>, return a <a>promise</a> rejected with an "{{InvalidStateError}}" exception.
        1. Let |promise| be a new <a>promise</a>.
        1. Run the following substeps <a>in parallel</a>:
          1. For each <a>service worker client</a> |client| whose <a for="service worker client">origin</a> is the <a lt="same origin">same</a> as the <a for="ServiceWorkerGlobalScope">service worker</a>'s <a for="resource">origin</a>:
            1. If |client| is a type of <a>environment</a>, then:
              1. If |client|’s <a>creation URL</a> is not a <a>potentially trustworthy URL</a>, continue to the next iteration of the loop.
            1. Else:
              1. If |client| is not a <a>secure context</a>, continue to the next iteration of the loop.
            1. Let |registration| be the result of running <a>Match Service Worker Registration</a> algorithm passing |client|'s <a>creation URL</a> as the argument.
            1. If |registration| is not the <a for="ServiceWorkerGlobalScope">service worker</a>'s <a>containing service worker registration</a>, continue to the next iteration of the loop.
            1. If |client|'s <a>active service worker</a> is not the <a for="ServiceWorkerGlobalScope">service worker</a>, then:
              1. Invoke <a>Handle Service Worker Client Unload</a> with |client| as the argument.
              1. Set |client|'s <a>active service worker</a> to <a for="ServiceWorkerGlobalScope">service worker</a>.
              1. Invoke <a>Notify Controller Change</a> algorithm with |client| as the argument.
          1. Resolve |promise| with undefined.
        1. Return |promise|.
    </section>
  </section>

  <section>
    <h3 id="extendableevent-interface">{{ExtendableEvent}}</h3>

    <pre class="idl">
      [Constructor(DOMString type, optional ExtendableEventInit eventInitDict), Exposed=ServiceWorker]
      interface ExtendableEvent : Event {
        void waitUntil(Promise&lt;any&gt; f);
      };
    </pre>
    <pre class="idl" id="extendable-event-init-dictionary">
      dictionary ExtendableEventInit : EventInit {
        // Defined for the forward compatibility across the derived events
      };
    </pre>

    An {{ExtendableEvent}} object has an associated <dfn for="ExtendableEvent">extend lifetime promises</dfn> (an array of <a>promises</a>). It is initially an empty array.

    An {{ExtendableEvent}} object has an associated <dfn id="extensions-allowed-flag">extensions allowed flag</dfn>. It is initially set.

    <a>Service workers</a> have two <a>lifecycle events</a>, <code><a>install</a></code> and <code><a>activate</a></code>. <a>Service workers</a> use the {{ExtendableEvent}} interface for <code><a>activate</a></code> event and <code><a>install</a></code> event.

    <a href="#extensibility">Service worker extensions</a> that <a>define event handlers</a> *may* also use or extend the {{ExtendableEvent}} interface.

    When <a>dispatching</a> an event |e| that uses the {{ExtendableEvent}} interface, the user agent *must* run these steps:

      1. If |e|'s <a>extend lifetime promises</a> is empty, unset |e|'s <a>extensions allowed flag</a> and abort these steps.
      1. Let |extendLifetimePromises| be an empty array.
      1. Run the following substeps <a>in parallel</a>:
        1. <em>SetupPromiseArray</em>: Set |extendLifetimePromises| to a copy of |e|'s <a>extend lifetime promises</a>.
        1. Wait until all the <a>promises</a> in |extendLifetimePromises| settle.
        1. If the length of |extendLifetimePromises| does not equal the length of |e|'s <a>extend lifetime promises</a>, jump to the step labeled <em>SetupPromiseArray</em>.
        1. Unset |e|'s <a>extensions allowed flag</a>.

    The user agent *should not* <a>terminate</a> the <a for="/">service worker</a> associated with |e|'s <a>relevant settings object</a>'s <a for="environment settings object">global object</a> until |e|'s <a>extensions allowed flag</a> is unset. However, the user agent *may* impose a time limit to this lifetime extension.

    <section algorithm="wait-until-method">
      <h4 id="wait-until-method">{{ExtendableEvent/waitUntil(f)|event.waitUntil(f)}}</h4>

      {{ExtendableEvent/waitUntil(f)}} method extends the lifetime of the event.

      <dfn method for="ExtendableEvent"><code>waitUntil(|f|)</code></dfn> method *must* run these steps:

        1. If the <a>extensions allowed flag</a> is unset, then:
          1. <a>Throw</a> an "{{InvalidStateError}}" exception.
          1. Abort these steps.
        1. Add |f| to the <a for="ExtendableEvent">extend lifetime promises</a>.
    </section>

    <a>Service workers</a> and <a href="#extensibility">extensions</a> that <a>define event handlers</a> *may* define their own behaviors, allowing the <a for="ExtendableEvent">extend lifetime promises</a> to suggest operation length, and the rejected state of any of the <a>promise</a> in <a for="ExtendableEvent">extend lifetime promises</a> to suggest operation failure.

    <a>Service workers</a> define the following behaviors for <code><a>install</a></code> event and <code><a>activate</a></code> event, respectively:

      * Adding a <a>promise</a> |f| to the event's <a>extend lifetime promises</a> delays treating the <a>installing worker</a> as <em><a>installed</a></em> (i.e. a <a>waiting worker</a>) until all the <a>promises</a> in the <a>extend lifetime promises</a> resolve successfully. (See step 11.3.1 of <a>Install</a> algorithm.) If |f| rejects, the installation fails. This is primarily used to ensure that a <a>service worker</a> is not considered <em><a>installed</a></em> (i.e. a <a>waiting worker</a>) until all of the core caches it depends on are populated.
      * Adding a <a>promise</a> to the event's <a>extend lifetime promises</a> delays treating the <a>active worker</a> as <em><a>activated</a></em> until all the <a>promises</a> in the <a>extend lifetime promises</a> settle. (See step 12.3 of <a>Activate</a> algorithm.) This is primarily used to ensure that any <a>functional events</a> are not dispatched to the {{ServiceWorkerGlobalScope}} object that represents the <a>service worker</a> until it upgrades database schemas and deletes the outdated cache entries.
  </section>

  <section>
    <h3 id="installevent-interface">{{InstallEvent}}</h3>

    <pre class="idl">
      [Constructor(DOMString type, optional ExtendableEventInit eventInitDict), Exposed=ServiceWorker]
      interface InstallEvent : ExtendableEvent {
        void registerForeignFetch(ForeignFetchOptions options);
      };

      dictionary ForeignFetchOptions {
        required sequence&lt;USVString&gt; scopes;
        required sequence&lt;USVString&gt; origins;
      };
    </pre>

    <section>
      <h4 id="register-foreign-fetch-method">{{InstallEvent/registerForeignFetch(options)|event.registerForeignFetch(options)}}</h4>

      {{InstallEvent/registerForeignFetch(options)}} registers this service worker to handle foreign fetches from certain origins for certain sub scopes.

      <dfn method for="InstallEvent"><code>registerForeignFetch(|options|)</code></dfn> method *must* run these steps:

        1. If the <a>dispatch flag</a> is unset, then:
          1. <a>Throw</a> an "<code><a>InvalidStateError</a></code>" exception.
          1. Abort these steps.
        1. If |options|.{{ForeignFetchOptions/origins}} is empty <a>throw</a> a <code>TypeError</code> and abort these steps.
        1. Let |originURLs| be an empty list of <a for="/">URLs</a>.
        1. If the value of |options|.{{ForeignFetchOptions/origins}} is not a single string equal to a single U+002A ASTERISK character (*):
          1. For each |origin| in |options|.|origins|:
            1. If the value of |origin| is not an <a>absolute-URL string</a>, <a>throw</a> a <code>TypeError</code> and abort these steps.
            1. Add the result of <a lt="URL parser">parsing</a> |origin| to |originURLs|.
        1. If |options|.{{ForeignFetchOptions/scopes}} is empty <a>throw</a> a <code>TypeError</code> and abort these steps.
        1. Let |scopeString| be the <a>context object</a>'s <a>relevant global object</a>'s <a for="ServiceWorkerGlobalScope">service worker</a>'s <a>containing service worker registration</a>'s <a for="service worker registration">scope url</a>, <a lt="URL serializer">serialized</a>.
        1. Let |subScopeURLs| be an empty list of <a for="/">URLs</a>.
        1. For each |subScope| in |options|.{{ForeignFetchOptions/scopes}}:
          1. Let |subScopeURL| be the result of <a lt="URL parser">parsing</a> |subScope| with <a>context object</a>'s <a>relevant settings object</a>'s <a>API base URL</a>.
          1. If |subScopeURL| is failure, <a>throw</a> a <code>TypeError</code> and abort these steps.
          1. Let |subScopeString| be the <a lt="URL serializer">serialized</a> |subScopeURL|.
          1. If |subScopeString| does not start with |scopeString|, <a>throw</a> a <code>TypeError</code> and abort these steps.
          1. Add |subScopeURL| to |subScopeURLs|.
        1. Set this <a>service worker</a>'s <a>list of foreign fetch scopes</a> to |subScopeURLs|.
        1. Set this <a>service worker</a>'s <a>list of foreign fetch origins</a> to |originURLs|.
    </section>
  </section>

  <section>
    <h3 id="fetchevent-interface">{{FetchEvent}}</h3>

    <pre class="idl">
      [Constructor(DOMString type, FetchEventInit eventInitDict), Exposed=ServiceWorker]
      interface FetchEvent : ExtendableEvent {
        [SameObject] readonly attribute Request request;
        readonly attribute DOMString clientId;
        readonly attribute DOMString reservedClientId;
        readonly attribute DOMString targetClientId;
        readonly attribute boolean isReload;

        void respondWith(Promise&lt;Response&gt; r);
      };
    </pre>
    <pre class="idl" id="fetch-event-init-dictionary">
      dictionary FetchEventInit : ExtendableEventInit {
        required Request request;
        DOMString clientId = "";
        DOMString reservedClientId = "";
        DOMString targetClientId = "";
        boolean isReload = false;
      };
    </pre>

    <a>Service workers</a> have an essential <a>functional event</a> <code><a>fetch</a></code>. For <code><a>fetch</a></code> event, <a>service workers</a> use the {{FetchEvent}} interface which extends the {{ExtendableEvent}} interface.

    Each event using {{FetchEvent}} interface has an associated <dfn for="FetchEvent">potential response</dfn> (a <a for="fetch">response</a>), initially set to null, and the following associated flags that are initially unset:

      * <dfn for="FetchEvent">wait to respond flag</dfn>
      * <dfn for="FetchEvent">respond-with entered flag</dfn>
      * <dfn for="FetchEvent">respond-with error flag</dfn>
    

    <section>
      <h4 id="fetch-event-request">{{FetchEvent/request|event.request}}</h4>

      <dfn attribute for="FetchEvent"><code>request</code></dfn> attribute *must* return the value it was initialized to.
    </section>

    <section>
      <h4 id="fetch-event-clientid">{{FetchEvent/clientId|event.clientId}}</h4>

      <dfn attribute for="FetchEvent"><code>clientId</code></dfn> attribute *must* return the value it was initialized to. When an <a>event</a> is created the attribute *must* be initialized to the empty string.
    </section>

    <section>
      <h4 id="fetch-event-reservedclientid">{{FetchEvent/reservedClientId|event.reservedClientId}}</h4>

      <dfn attribute for="FetchEvent"><code>reservedClientId</code></dfn> attribute *must* return the value it was initialized to. When an <a>event</a> is created the attribute *must* be initialized to the empty string.
    </section>

    <section>
      <h4 id="fetch-event-targetclientid">{{FetchEvent/targetClientId|event.targetClientId}}</h4>

      <dfn attribute for="FetchEvent"><code>targetClientId</code></dfn> attribute *must* return the value it was initialized to. When an <a>event</a> is created the attribute *must* be initialized to the empty string.
    </section>

    <section>
      <h4 id="fetch-event-isreload">{{FetchEvent/isReload|event.isReload}}</h4>

      <dfn attribute for="FetchEvent"><code>isReload</code></dfn> attribute *must* return the value it was initialized to. When an <a>event</a> is created the attribute *must* be initialized to false.

      Note: Pressing the refresh button should be considered a reload while clicking a link and pressing the back button should not. The behavior of Ctrl+l enter is left to the implementations of the user agents.
    </section>

    <section algorithm="fetch-event-respondwith">
      <h4 id="fetch-event-respondwith">{{FetchEvent/respondWith(r)|event.respondWith(r)}}</h4>

      Note: Developers can set the argument |r| with either a <a>promise</a> that resolves with a {{Response}} object or a {{Response}} object (which is automatically cast to a promise). Otherwise, a <a>network error</a> is returned to <a>Fetch</a>. Renderer-side security checks about tainting for cross-origin content are tied to the types of <a>filtered responses</a> defined in <a>Fetch</a>.

      <dfn method for="FetchEvent"><code>respondWith(|r|)</code></dfn> method *must* run these steps:

      <div link-for-hint="FetchEvent">
        1. If the <a>dispatch flag</a> is unset, then:
          1. <a>Throw</a> an "{{InvalidStateError}}" exception.
          1. Abort these steps.
        1. If the <a for="FetchEvent">respond-with entered flag</a> is set, then:
          1. <a>Throw</a> an "{{InvalidStateError}}" exception.
          1. Abort these steps.
        1. Add |r| to the <a>extend lifetime promises</a>.
          
          Note: {{FetchEvent/respondWith(r)|event.respondWith(r)}} extends the lifetime of the event by default as if {{ExtendableEvent/waitUntil(f)|event.waitUntil(r)}} is called.

        1. Set the <a>stop propagation flag</a> and <a>stop immediate propagation flag</a>.
        1. Set the <a for="FetchEvent">respond-with entered flag</a>.
        1. Set the <a for="FetchEvent">wait to respond flag</a>.
        1. Let |targetRealm| be the <a>relevant Realm</a> of the <a>context object</a>.
        1. Run the following substeps <a>in parallel</a>:
          1. Wait until |r| settles.
          1. If |r| rejected, then:
            1. Set the <a for="FetchEvent">respond-with error flag</a>.
          1. If |r| resolved with |response|, then:
            1. If |response| is a {{Response}} object, then:
              1. If |response| is <a>disturbed</a> or <a>locked</a>, then:
                1. Set the <a for="FetchEvent">respond-with error flag</a>.
              1. Else:
                1. Let |bytes| be an empty byte sequence.
                1. Let |end-of-body| be false.
                1. Let |done| be false.
                1. Let |potentialResponse| be a copy of |response|'s associated <a for="response">response</a>, except for its <a for="response">body</a>.
                1. If |response|'s <a for="Body">body</a> is non-null, run these substeps:
                  1. Let |reader| be the result of <a lt="get a reader">getting a reader</a> from |response|'s <a for="Body">body</a>'s <a>stream</a>.
                  1. Let |strategy| be an object created in |targetRealm|. The user agent may choose any object.
                  1. Let |pull| be an action that runs these subsubsteps:
                    1. Let |promise| be the result of <a lt="read a chunk from a ReadableStream">reading</a> a chunk from |response|'s <a for="Body">body</a>'s <a>stream</a> with |reader|.
                    1. When |promise| is fulfilled with an object whose <code>done</code> property is false and whose <code>value</code> property is a <code>Uint8Array</code> object, append the bytes represented by the <code>value</code> property to |bytes| and perform ! <a>DetachArrayBuffer</a> with the <code>ArrayBuffer</code> object wrapped by the <code>value</code> property.
                    1. When |promise| is fulfilled with an object whose <code>done</code> property is true, set |end-of-body| to true.
                    1. When |promise| is fulfilled with a value that matches with neither of the above patterns, or |promise| is rejected, <a lt="error ReadableStream">error</a> |newStream| with a <code>TypeError</code>.
                  1. Let |cancel| be an action that <a lt="cancel a ReadableStream">cancels</a> |response|'s <a for="Body">body</a>'s <a>stream</a> with |reader|.
                  1. Let |newStream| be the result of <a lt="construct a ReadableStream">constructing</a> a ReadableStream object with |strategy|, |pull| and |cancel| in |targetRealm|.
                  1. Set |potentialResponse|'s <a for="response">body</a> to a new <a for="/">body</a> whose <a>stream</a> is |newStream|.
                  1. Run these subsubsteps repeatedly <a>in parallel</a> while |done| is false:
                    1. If |newStream| is <a>errored</a>, then set |done| to true.
                    1. Otherwise, if |bytes| is empty and |end-of-body| is true, then <a lt="close ReadableStream">close</a> |newStream| and set |done| to true.
                    1. Otherwise, if |bytes| is not empty, run these subsubsubsteps:
                      1. Let |chunk| be a subsequence of |bytes| starting from the beginning of |bytes|.
                      1. Remove |chunk| from |bytes|.
                      1. Let |buffer| be an <code>ArrayBuffer</code> object created in |targetRealm| and containing |chunk|.
                      1. <a lt="enqueue a chunk to ReadableStream">Enqueue</a> a <code>Uint8Array</code> object created in |targetRealm| and wrapping |buffer| to |newStream|.

                  Note: These substeps are meant to produce the observable equivalent of "piping" |response|'s <a for="Body">body</a>'s <a>stream</a> into |potentialResponse|.
                
                1. Set the <a for="FetchEvent">potential response</a> to |potentialResponse|.
            1. Else:
                1. Set the <a for="FetchEvent">respond-with error flag</a>.

                  Note: If the <a for="FetchEvent">respond-with error flag</a> is set, a <a>network error</a> is returned to <a>Fetch</a> through <a>Handle Fetch</a> algorithm. (See the step 21.1.) Otherwise, the value |response| is returned to <a>Fetch</a> through <a>Handle Fetch</a> algorithm. (See the step 22.1.)

          1. Unset the <a for="FetchEvent">wait to respond flag</a>.
      </div>
    </section>
  </section>

  <section>
    <h3 id="foreignfetchevent-interface">{{ForeignFetchEvent}}</h3>

    <pre class="idl">
      [Constructor(DOMString type, ForeignFetchEventInit eventInitDict), Exposed=ServiceWorker]
      interface ForeignFetchEvent : ExtendableEvent {
        [SameObject] readonly attribute Request request;
        readonly attribute USVString origin;

        void respondWith(Promise&lt;ForeignFetchResponse&gt; r);
      };

      dictionary ForeignFetchEventInit : ExtendableEventInit {
        required Request request;
        USVString origin = "null";
      };

      dictionary ForeignFetchResponse {
        required Response response;
        USVString origin;
        sequence&lt;ByteString&gt; headers;
      };
    </pre>

    <a>Service workers</a> have a <a>functional event</a> <code><a>foreignfetch</a></code>. For <code><a>foreignfetch</a></code> events, <a>service workers</a> use the {{ForeignFetchEvent}} interface which extends the {{ExtendableEvent}} interface.

    Each event using {{ForeignFetchEvent}} interface has an associated <dfn for="ForeignFetchEvent">potential response</dfn> (a <a for="fetch">response</a>), initially set to null, an associated <dfn for="ForeignFetchEvent">origin</dfn> (a {{USVString}} or null), initially set to null, an associated <dfn>list of exposed headers</dfn> (whose element type is a byte string), initially set to an empty list, and the following associated flags that are initially unset:

        * <dfn for="ForeignFetchEvent">wait to respond flag</dfn>
        * <dfn for="ForeignFetchEvent">respond-with entered flag</dfn>
        * <dfn for="ForeignFetchEvent">respond-with error flag</dfn>

    <section>
      <h4 id="foreign-fetch-event-request">{{ForeignFetchEvent/request|event.request}}</h4>

      The <dfn attribute for="ForeignFetchEvent"><code>request</code></dfn> attribute *must* return the value it was initialized to.
    </section>

    <section>
      <h4 id="foreign-fetch-event-origin">{{ForeignFetchEvent/origin|event.origin}}</h4>

      The <dfn attribute for="ForeignFetchEvent"><code>origin</code></dfn> attribute *must* return the value it was initialized to.
    </section>

    <section algorithm="foreign-fetch-event-respondwith">
      <h4 id="foreign-fetch-event-respondwith">{{ForeignFetchEvent/respondWith(r)|event.respondWith(r)}}</h4>

      Note: Developers can set the argument |r| with either a <a>promise</a> that resolves with a {{Response}} object or a {{Response}} object (which is automatically cast to a promise). Otherwise, a <a>network error</a> is returned to <a>Fetch</a>. Renderer-side security checks about tainting for cross-origin content are tied to the types of <a>filtered responses</a> defined in <a>Fetch</a>.

      <dfn method for="ForeignFetchEvent"><code>respondWith(|r|)</code></dfn> method *must* run these steps:

      <div link-for-hint="ForeignFetchEvent">
        1. If the <a>dispatch flag</a> is unset, then:
          1. <a>Throw</a> an "{{InvalidStateError}}" exception.
          1. Abort these steps.
        1. If the <a for="ForeignFetchEvent">respond-with entered flag</a> is set, then:
          1. <a>Throw</a> an "{{InvalidStateError}}" exception.
          1. Abort these steps.
        1. Add |r| to the <a>extend lifetime promises</a>.
        1. Set the <a>stop propagation flag</a> and <a>stop immediate propagation flag</a>.
        1. Set the <a for="ForeignFetchEvent">respond-with entered flag</a>.
        1. Set the <a for="ForeignFetchEvent">wait to respond flag</a>.
        1. Let |targetRealm| be the <a>relevant Realm</a> of the <a>context object</a>.
        1. Run the following substeps <a>in parallel</a>:
          1. Wait until |r| settles.
          1. If |r| rejected, then:
            1. Set the <a for="ForeignFetchEvent">respond-with error flag</a>.
          1. If |r| resolved with |response|, then:
            1. If |response| is a {{ForeignFetchResponse}}, then:
              1. Set the <a for="ForeignFetchEvent">origin</a> to |response|.{{ForeignFetchResponse/origin}}.
              1. Set the <a>list of exposed headers</a> to |response|.{{ForeignFetchResponse/headers}}.
              1. If |response|.{{ForeignFetchResponse/response}} is <a>disturbed</a> or <a>locked</a>, then:
                1. Set the <a for="ForeignFetchEvent">respond-with error flag</a>.
              1. Else:
                1. Let |bytes| be an empty byte sequence.
                1. Let |end-of-body| be false.
                1. Let |done| be false.
                1. Let |potentialResponse| be a copy of |response|.{{ForeignFetchResponse/response}}'s associated <a>response</a>, except for its <a for="response">body</a>.
                1. If |response|.{{ForeignFetchResponse/response}}'s body is non-null, run these substeps:
                  1. Let |reader| be the result of <a lt="get a reader">getting a reader</a> from |response|.{{ForeignFetchResponse/response}}'s <a for="Body">body</a>'s <a>stream</a>.
                  1. Let |strategy| be an object created in |targetRealm|. The user agent may choose any object.
                  1. Let |pull| be an action that runs these subsubsteps:
                    1. Let |promise| be the result of <a lt="read a chunk from a ReadableStream">reading</a> a chunk from |response|.{{ForeignFetchResponse/response}}'s <a for="Body">body</a>'s <a>stream</a> with |reader|.
                    1. When |promise| is fulfilled with an object whose <code>done</code> property is false and whose <code>value</code> property is a <code>Uint8Array</code> object, append the bytes represented by the <code>value</code> property to |bytes| and perform ! <a>DetachArrayBuffer</a> with the <code>ArrayBuffer</code> object wrapped by the <code>value</code> property.
                    1. When |promise| is fulfilled with an object whose <code>done</code> property is true, set |end-of-body| to true.
                    1. When |promise| is fulfilled with a value that matches with neither of the above patterns, or |promise| is rejected, <a lt="error ReadableStream">error</a> |newStream| with a <code>TypeError</code>.
                  1. Let |cancel| be an action that <a lt="cancel a ReadableStream">cancels</a> |response|.{{ForeignFetchResponse/response}}'s <a for="Body">body</a>'s <a>stream</a> with |reader|.
                  1. Let |newStream| be the result of <a lt="construct a ReadableStream">constructing</a> a ReadableStream object with |strategy|, |pull| and |cancel| in |targetRealm|.
                  1. Set |potentialResponse|'s <a for="response">body</a> to a new <a for="/">body</a> whose <a>stream</a> is |newStream|.
                  1. Run these subsubsteps repeatedly <a>in parallel</a> while |done| is false:
                    1. If |newStream| is <a>errored</a>, then set |done| to true.
                    1. Otherwise, if |bytes| is empty and |end-of-body| is true, then <a lt="close ReadableStream">close</a> |newStream| and set |done| to true.
                    1. Otherwise, if |bytes| is not empty, run these subsubsubsteps:
                      1. Let |chunk| be a subsequence of |bytes| starting from the beginning of |bytes|.
                      1. Remove |chunk| from |bytes|.
                      1. Let |buffer| be an <code>ArrayBuffer</code> object created in |targetRealm| and containing |chunk|.
                      1. <a lt="enqueue a chunk to ReadableStream">Enqueue</a> a <code>Uint8Array</code> object created in |targetRealm| and wrapping |buffer| to |newStream|.
                1. Set the <a for="ForeignFetchEvent">potential response</a> to |potentialResponse|.
            1. Else:
              1. Set the <a for="ForeignFetchEvent">respond-with error flag</a>.

              Note: If the <a for="ForeignFetchEvent">respond-with error flag</a> is set, a <a>network error</a> is returned to <a>Fetch</a> through [[#on-foreign-fetch-request-algorithm]] algorithm. (See the step 19.1.) Otherwise, a filtered version of |response| is returned to <a>Fetch</a> through [[#on-foreign-fetch-request-algorithm]] algorithm. (See the step 20.1.)

          1. Unset the <a for="ForeignFetchEvent">wait to respond flag</a>.
      </div>
    </section>
  </section>

  <section>
    <h3 id="extendablemessageevent-interface">{{ExtendableMessageEvent}}</h3>

    <pre class="idl">
      [Constructor(DOMString type, optional ExtendableMessageEventInit eventInitDict), Exposed=ServiceWorker]
      interface ExtendableMessageEvent : ExtendableEvent {
        readonly attribute any data;
        readonly attribute USVString origin;
        readonly attribute DOMString lastEventId;
        [SameObject] readonly attribute (Client or ServiceWorker or MessagePort)? source;
        readonly attribute FrozenArray&lt;MessagePort&gt; ports;
      };
    </pre>
    <pre class="idl" id="extendablemessage-event-init-dictionary">
      dictionary ExtendableMessageEventInit : ExtendableEventInit {
        any data = null;
        USVString origin = "";
        DOMString lastEventId = "";
        (Client or ServiceWorker or MessagePort)? source = null;
        sequence&lt;MessagePort&gt; ports = [];
      };
    </pre>

    <a>Service workers</a> define the <a>extendable</a> {{message!!event}} event to allow extending the lifetime of the event. For the {{message!!event}} event, <a>service workers</a> use the {{ExtendableMessageEvent}} interface which extends the {{ExtendableEvent}} interface.

    <section>
      <h4 id="extendablemessage-event-data">{{ExtendableMessageEvent/data|event.data}}</h4>

      The <dfn attribute for="ExtendableMessageEvent">data</dfn> attribute *must* return the value it was initialized to. When the object is created, this attribute *must* be initialized to null. It represents the message being sent.
    </section>

    <section>
      <h4 id="extendablemessage-event-origin">{{ExtendableMessageEvent/origin|event.origin}}</h4>

      The <dfn attribute for="ExtendableMessageEvent">origin</dfn> attribute *must* return the value it was initialized to. When the object is created, this attribute *must* be initialized to the empty string. It represents the <a for="resource">origin</a> of the <a>service worker client</a> that sent the message.
    </section>

    <section>
      <h4 id="extendablemessage-event-lasteventid">{{ExtendableMessageEvent/lastEventId|event.lastEventId}}</h4>

      The <dfn attribute for="ExtendableMessageEvent">lastEventId</dfn> attribute *must* return the value it was initialized to. When the object is created, this attribute *must* be initialized to the empty string.
    </section>

    <section>
      <h4 id="extendablemessage-event-source">{{ExtendableMessageEvent/source|event.source}}</h4>

      The <dfn attribute for="ExtendableMessageEvent">source</dfn> attribute *must* return the value it was initialized to. When the object is created, this attribute *must* be initialized to null. It represents the {{Client}} object from which the message is sent.
    </section>

    <section>
      <h4 id="extendablemessage-event-ports">{{ExtendableMessageEvent/ports|event.ports}}</h4>

      The <dfn attribute for="ExtendableMessageEvent">ports</dfn> attribute *must* return the value it was initialized to. When the object is created, this attribute *must* be initialized to the empty array. It represents the {{MessagePort}} array being sent.
    </section>
  </section>

  <section>
    <h3 id="execution-context-events">Events</h3>

    The following events are dispatched on {{ServiceWorkerGlobalScope}} object:

    <table class="data" dfn-for="ServiceWorkerGlobalScope">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when&mldr;</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn event id="service-worker-global-scope-install-event"><code>install</code></dfn></td>
          <td>{{InstallEvent}}</td>
          <td>[<a>Lifecycle event</a>] The <a for="ServiceWorkerGlobalScope">service worker</a>'s <a>containing service worker registration</a>'s <a>installing worker</a> changes. (See step 11.2 of the <a>Install</a> algorithm.)</td>
        </tr>
        <tr>
          <td><dfn event id="service-worker-global-scope-activate-event"><code>activate</code></dfn></td>
          <td>{{ExtendableEvent}}</td>
          <td>[<a>Lifecycle event</a>] The <a for="ServiceWorkerGlobalScope">service worker</a>'s <a>containing service worker registration</a>'s <a>active worker</a> changes. (See step 12.2 of the <a>Activate</a> algorithm.)</td>
        </tr>
        <tr>
          <td><dfn event id="service-worker-global-scope-fetch-event"><code>fetch</code></dfn></td>
          <td>{{FetchEvent}}</td>
          <td>[<a>Functional event</a>] The <a>http fetch</a> invokes <a>Handle Fetch</a> with |request|. As a result of performing <a>Handle Fetch</a>, the <a for="ServiceWorkerGlobalScope">service worker</a> returns a <a for="fetch">response</a> to the <a>http fetch</a>. The <a for="fetch">response</a>, represented by a {{Response}} object, can be retrieved from a {{Cache}} object or directly from network using {{WindowOrWorkerGlobalScope/fetch(input, init)|self.fetch(input, init)}} method. (A custom {{Response}} object can be another option.)</td>
        </tr>
        <tr>
          <td><dfn event id="service-worker-global-scope-foreignfetch-event"><code>foreignfetch</code></dfn></td>
          <td>{{FetchEvent}}</td>
          <td>[<a>Functional event</a>] The <a>http fetch</a> invokes [[#on-foreign-fetch-request-algorithm]] with |request|. As a result of performing [[#on-foreign-fetch-request-algorithm]], the <a for="ServiceWorkerGlobalScope">service worker</a> returns a <a for="fetch">response</a> to the <a>http fetch</a>. The <a for="fetch">response</a>, represented by a {{Response}} object, can be retrieved from a {{Cache}} object or directly from network using {{WindowOrWorkerGlobalScope/fetch(input, init)|self.fetch(input, init)}} method. (A custom {{Response}} object can be another option.)</td>
        </tr>
        <tr>
          <td><dfn event><code>message</code></dfn></td>
          <td>{{ExtendableMessageEvent}}</td>
          <td>When it receives a message.</td>
        </tr>
      </tbody>
    </table>
  </section>
</section>